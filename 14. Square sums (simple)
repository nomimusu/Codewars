function square_sums_row(n, r=[]){
  return DFS(n,new Set(),r) ? r : false;
}

const DFS = function(n, set, r){
  // r用来存储最终的序列
  // set用来保存已经使用过的数字
  // 如果set的数字等于n，说明所有的数字都已被使用，找到了正确的解
  if(set.size === n) return true;
  
  //遍历从1到n的每一个数字
  for(let i = 1; i<=n; i++){
    //如果i已经被使用，直接跳过i，判断下一个数
    if (set.has(i)) continue;
    // Math.sqrt(r[0] + i)%1 !== 0, 说明r[0]与i的和不是一个完美平方数，直接跳过i，判断下一个数
    if (r.length && Math.sqrt(r[0] + i)%1 !== 0) continue;
    
    //经过前两个条件的判断，说明Math.sqrt(r[0] + i) % 1 === 0,即r[0]+i是一个完美平方数, 注意：并不是所有的数当中只有现在的i与r[0]的和是完美平方数。
    // 例如1 与 3，8，15的和都是一个完美平方数
    //将i加入到集合set中
    //将i插入到当前排列r的开头
    r.unshift(i);
    set.add(i);
    
    //递归调用DFS，上一步的i已经变成了r[0], 需要找一个新的i，看两者之和是否为完美平方数
    if(DFS(n,set,r)) return true;
    
    //如果其中一个分支不是一个有效解，返回上一个状态，进行其他分支的尝试
    //如果递归调用DFS返回false，说明这个分支不能够导向一个正确的解，所以要返回上一个分支，去尝试第二种分支（即回溯）
    // 1与3，8，15的和都是一个完美平方数，所以1底下有3个分支3，8，15；尝试分支1-3
    // 3与6，13的和是一个完美平方数，所以3底下有2个分支6，13；尝试分支1-3-6
    // 6与10的和是一个完美平方数，所以6底下有1个分支10；尝试分支1-3-6-10
    // 10与15的和是一个完美平方数，所以10底下有1个分支15，尝试分支1-3-6-10-15
    // 15与除去1，3，6，10，15的其他数字的和都不是完美平方数，所以分支1-3-6-10-15不是一个有效解，返回上一个状态1-3-6-10，不是一个有效解
    // 返回上一个状态1-3-6，不是一个有效解，返回上一个状态1-3，尝试分支1-3-13
    // 13与除去1，3，13的其他数字的和都不是完美平方数，不是一个有效解。所以3底下的分支6和13都不是有效解，返回上一个状态，尝试分支1-8
    r.shift(i);
    set.delete(i);
  }
  
  return false;
}
